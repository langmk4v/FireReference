# Fire 言語仕様書

**リファレンス実装のための詳細かつ具体的な仕様書**

TODO が書いてある箇所は、書いてる途中であることを意味します。

2026 ringo.

> **目次**
>   - [A. 字句解析 (Lexer)]()
>       - [1. 数値リテラル]()
>       - [2. 文字・文字列リテラル]()
>       - [3. 名前 (識別子)]()
>       - [4. キーワード (予約語)]()
>       - [5. 演算子]()
>       - [6. 記号]()
>   - [B. 構文解析 (Parser)]()
>       - [1. シンボル]()
>       - [2. 型名]()
>           - [型名を使用可能な場所](#型を記述できる箇所の一覧:)
>           - [式中での型名の使用](#式中に型名が含まれる場合)
>       - [3. 式]()
>           - [演算子の優先順位]()
>           - [factor: リテラル・シンボル]()
>           - [primary: 関数呼び出し・配列添字・メンバアクセス]()
>           - [unary: 単項算術演算]()
>           - [terms: 二項算術演算]()
>           - [shift: シフト演算]()
>           - [compare: 比較]()
>           - [equality: 等価比較]()
>           - [bit: ビット演算]()
>           - [log: ブール型比較]()
>           - [assign: 代入]()
>           - [expr: 式]()
>       - [4. 文]()
>           - [条件文]()
>               - [if]()
>               - [match]()
>               - [switch]()
>           - [繰り返し文]()
>               - [for]()
>               - [loop]()
>               - [do-while]()
>               - [while]()
>           - [単文]()
>               - [return]()
>               - [break]()
>               - [continue]()
>           - [変数定義 (var)]()
>           - [例外処理 (try-catch)]() 
>           - [式文]()
>           - [スコープ]()
>       - [5. 関数]()
>       - [6. 列挙型]()
>       - [7. クラス]()
>       - [8. 名前空間]()
>   - [C. 型システム (TypeInfo)]()
>       - [1. ]()
>   - [D. 意味解析 (Sema)]()
>       - [1. スコープ構築](#1-スコープ情報の構築)
>       - [2. シンボル収集]()
>       - [3. 名前解決]()
>       - [4. 整合性・型チェック]()
>   - [E. 構文木の評価 (EvalNode)]()
>       - [1. スタック]()
>       - [2. 式の評価]()
>       - [3. 文の実行]()
>   - [F. コンパイル (LLVM-IR)]()
>       - Feature...
>   - [G. アプリケーション (Driver)]()
>       - [1. ソースファイル管理]()
>           - [ファイル読み取り]()
>           - [外部モジュール取り込み (import)]()
>       - [2. コマンドライン引数]()
>   - [H. コマンドライン実行 (REPL)]()




------------

# A. 字句解析

## 1. 数値リテラル
```
INTEGER     :=  [0-9]+
FLOAT       :=  [0-9]+\.?[0-9]*f?
```

## 2. 文字・文字列リテラル
```
CHAR        :=  '(.|\\[a-z|A-Z])'
STRING      :=  "(.|\\[a-z|A-Z])*"
```

## 3. 識別子

```
IDENTIFIER  :=  (_|[a-z]|[A-Z])([a-z]|[A-Z]|[0-9])*
```

## 4. キーワード

ここから先は多分抜け漏れがあるかも。

| トークン名      | キーワード  |
|-----------------|-------------|
| `KWD_SELF`      | **self**    |
| `KWD_TRUE`      | **true**    |
| `KWD_FALSE`     | **false**   |
| `KWD_REF`       | **ref**     |
| `KWD_CONST`     | **const** |
| `KWD_VAR`       | **var** |
| `KWD_IF`        | **if** |
| `KWD_ELSE`      | **else** |
| `KWD_MATCH`     | **match** |
| `KWD_LOOP`      | **loop** |
| `KWD_FOR`       | **for** |
| `KWD_DO`        | **do** |
| `KWD_WHILE`     | **while** |
| `KWD_TRY`       | **try** |
| `KWD_CATCH`     | **catch** |
| `KWD_BREAK`     | **break** |
| `KWD_CONTINUE`  | **continue** |
| `KWD_RETURN`    | **return** |
| `KWD_FN`        | **fn** |
| `KWD_ENUM`      | **enum** |
| `KWD_CLASS`     | **class** |
| `KWD_NAMESPACE` | **namespace** |

## 5. 演算子
```
SCOPE_RESOL     ::

ADD             +
SUB             -
MUL             *
DIV             /
MOD             %

LSHIFT          <<
RSHIFT          >>

BIT_AND         &
BIT_OR          |
BIT_XOR         ^

INCLEMENT       ++
DECLEMENT       --

ASSIGN          =
ASSIGN_ADD      +=
ASSIGN_SUB      -=
ASSIGN_MUL      *=
ASSIGN_DIV      /=
ASSIGN_MOD      %=
ASSIGN_AND      &=
ASSIGN_OR       |=
ASSIGN_XOR      ^=
ASSIGN_LSHIFT   <<=
ASSIGN_RSHIFT   >>=
```
## 6. 記号
```
RIGHT_ARROW     ->
DOT             .
COMMA           ,
COLON           :
SEMICOLON       ;
EXCLAMATION     !
QUESTION        ?

HASH            #
DOLLER          $
BACKTICK        `
TILDE           ~

BRACKET_OPEN    (
BRACKET_CLOSE   )
SCOPE_OPEN      {
SCOPE_CLOSE     }
ANGLE_OPEN      <
ANGLE_CLOSE     >
ARRAY_OPEN      [
ARRAY_CLOSE     ]
```

--------------------------------------

--------------------------------------

# B. 構文解析 (Parser)

#### 言語としての構文の規則

> **曖昧な構文の禁止**
> Fire では曖昧な構文を使用しません。
> また、処理系においては、曖昧な構文木を作成することはできません。

--------------

## 1. シンボル
変数や関数などの名前を参照する識別子トークン、またはスコープ解決式のこと。
テンプレート引数リストを持つことができる。
テンプレート引数

> **結合規則 = なし**
>
> Syntax:
> ```
> symbol  :=  IDENT template-args? (SCOPE_RESOL symbol)?
>
> template-args  :=
>     ANGLE_OPEN 
> ```
> 
> Example:
> ```
> abc
> a::b
> func<int>
> MyClass<T>::func
> ```

> **大小比較式との明確な差別化**
> テンプレート引数リスト `< ... >` をパースしている最中に、リスト内の予期せぬ位置で `"<"` もしくは `">"` が現れた場合、またはそれ以外の原因でパースに失敗した場合、引数リストのパースを行いません。
> 引数リストのパースを中断して、パース直前のトークン位置に戻します。

--------------

## 2. 型名 (type-name)
基本型・組み込みクラス・ユーザー定義クラス・列挙型 のいずれかの名前を指す識別子トークン、またはスコープ解決式。
テンプレート引数を指定可能。（構文はシンボルのものと同義）
> **結合規則 = なし**
> Syntax:
> ```
> type-name  :=  IDENT template-args? (SCOPE_RESOL type-name)? KWD_CONST? KWD_REF?
> ```
> Example:
> ```
> ```

Fire 言語では、文とそれより上層の段階 ( 以下 `A` ) では、型名を記述できる場所は完全に決められている。
そこに到達したときに限り、型名のパーサを呼び出す。

### 型を記述できる箇所の一覧:
`A` に該当する構文に含まれる、全ての「型名を記述できる場所」を、以下に定義する。
> - シンボルもしくは型名のテンプレート引数の中 (`name<T, ...>`)
> - 関数の引数     (`a: T`)
> - 関数の戻り値   (`-> T`)

### 式中に型名が含まれる場合
式中に型名が含まれている場合は、
シンボルと型名のどちらに当てはまるのかという検査や走査はせず、*シンボルとして* パースします。
そこで、`ref` または `const` キーワードの出現により、シンボル名としてのパースが失敗した場合、型名としてパースを行います。

--------------

## 3. 式

### 演算子の優先順位
全ての演算子の優先順位を、高い順にここに定義する。

> #### 優先度 1
> **結合規則 = なし**
> | 演算子     | 名称                   |
> |------------|------------------------|
> | **`::`**   | **スコープ解決演算子** |

> #### 優先度 2
> **結合規則 = 左**
> | 演算子     | 名称                   |
> |------------|------------------------|
> | **`()`**   | **関数呼び出し**       |
> | **`[]`**   | **配列インデックス**   |
> | **`.`**    | **メンバアクセス**     |


### 終端

### プライマリ
### 単項算術
### 二項算術
### シフト演算
### 比較
### 等価比較
### ビット演算

--------------

## 4. 文

### 条件文
- `if`
```
if ::=
    "if" <cond: expr>
    <then-code: scope>
    ("else" (<if> | <scope>))?
```

### 繰り返し文
- `loop`
```
```
- `for`
```
```
- `foreach`
```
```
- `while`
```
```
- `do-while`
```
```

### 単文

- `return`
- `break`
- `continue`

### 変数定義 (`var`)
現在のスコープに変数を定義する。
すでに定義済みの場合は、シャドウイングをする。
> Syntax:
>   `var` `:=` `"var"` `IDENT` `(` `COLON` [`type-name`]() `)?` (ASSIGN expr
>
> Example:
> ```
> var a = 10;
> 
> ```

### 例外処理 (`try` `catch`)
```
try-catch   ::=
    <try-scope>
    <catch-scope> +
    <finally-scope>

try-scope   ::=
    "try" <scope>

catch-scope   ::=
    "catch" 
```

--------------

## 5. 関数

------------

## 6. 列挙型

------------

## 7. クラス

------------

## 8. 名前空間

--------------------------------------

--------------------------------------

# C. 型システム

TODO

--------------------------------------

--------------------------------------

# D. 意味解析

各フェーズごとに分けてプログラムの意味解析を行う。
構文木を探索して処理することは全てのフェーズに共通する。

## 1. スコープ情報の構築
Node を探索し、スコープを持つ Node を元に スコープ情報 (=SI) を構築する。
すべての S は、シンボルテーブル(=SymTBL) を保持する。
また、その S に名前がある場合、S の中にシンボル情報(=SYM) をもたせる。
```cpp
struct ScopeInfo {

}
```

## 2. シンボル収集
シンボルの定義情報を収集してシンボルテーブルを作成する。

## 3. 名前解決


## 4. 整合性・型チェック

------------

# E. 構文木の評価

------------

# F. コンパイル: LLVM-IR を生成

------------

# G. アプリケーション

------------

# H. REPL
